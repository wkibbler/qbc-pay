{"ast":null,"code":"var baddress = require('./address');\n\nvar bcrypto = require('./crypto');\n\nvar ecdsa = require('./ecdsa');\n\nvar randomBytes = require('randombytes');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar wif = require('wif');\n\nvar NETWORKS = require('./networks');\n\nvar BigInteger = require('bigi');\n\nvar ecurve = require('ecurve');\n\nvar secp256k1 = ecdsa.__curve;\n\nvar fastcurve = require('./fastcurve');\n\nfunction ECPair(d, Q, options) {\n  if (options) {\n    typeforce({\n      compressed: types.maybe(types.Boolean),\n      network: types.maybe(types.Network)\n    }, options);\n  }\n\n  options = options || {};\n\n  if (d) {\n    if (d.signum() <= 0) throw new Error('Private key must be greater than 0');\n    if (d.compareTo(secp256k1.n) >= 0) throw new Error('Private key must be less than the curve order');\n    if (Q) throw new TypeError('Unexpected publicKey parameter');\n    this.d = d;\n  } else {\n    typeforce(types.ECPoint, Q);\n    this.__Q = Q;\n  }\n\n  this.compressed = options.compressed === undefined ? true : options.compressed;\n  this.network = options.network || NETWORKS.bitcoin;\n}\n\nObject.defineProperty(ECPair.prototype, 'Q', {\n  get: function () {\n    if (!this.__Q && this.d) {\n      this.__Q = secp256k1.G.multiply(this.d);\n    }\n\n    return this.__Q;\n  }\n});\n\nECPair.fromPublicKeyBuffer = function (buffer, network) {\n  var Q = ecurve.Point.decodeFrom(secp256k1, buffer);\n  return new ECPair(null, Q, {\n    compressed: Q.compressed,\n    network: network\n  });\n};\n\nECPair.fromWIF = function (string, network) {\n  var decoded = wif.decode(string);\n  var version = decoded.version; // list of networks?\n\n  if (types.Array(network)) {\n    network = network.filter(function (x) {\n      return version === x.wif;\n    }).pop(); // We should not use pop since it depends on the order of the networks for the same wif\n\n    if (!network) throw new Error('Unknown network version'); // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n\n  var d = BigInteger.fromBuffer(decoded.privateKey);\n  return new ECPair(d, null, {\n    compressed: decoded.compressed,\n    network: network\n  });\n};\n\nECPair.makeRandom = function (options) {\n  options = options || {};\n  var rng = options.rng || randomBytes;\n  var d;\n\n  do {\n    var buffer = rng(32);\n    typeforce(types.Buffer256bit, buffer);\n    d = BigInteger.fromBuffer(buffer);\n  } while (d.signum() <= 0 || d.compareTo(secp256k1.n) >= 0);\n\n  return new ECPair(d, null, options);\n};\n\nECPair.prototype.getAddress = function () {\n  return baddress.toBase58Check(bcrypto.hash160(this.getPublicKeyBuffer()), this.getNetwork().pubKeyHash);\n};\n\nECPair.prototype.getNetwork = function () {\n  return this.network;\n};\n\nECPair.prototype.getPublicKeyBuffer = function () {\n  return this.Q.getEncoded(this.compressed);\n};\n/**\n * Get the private key as a 32 bytes buffer. If it is smaller than 32 bytes, pad it with zeros\n * @return Buffer\n */\n\n\nECPair.prototype.getPrivateKeyBuffer = function () {\n  if (!this.d) throw new Error('Missing private key');\n  var bigIntBuffer = this.d.toBuffer();\n  if (bigIntBuffer.length > 32) throw new Error('Private key size exceeds 32 bytes');\n\n  if (bigIntBuffer.length === 32) {\n    return bigIntBuffer;\n  }\n\n  var newBuffer = Buffer.alloc(32);\n  bigIntBuffer.copy(newBuffer, newBuffer.length - bigIntBuffer.length, 0, bigIntBuffer.length);\n  return newBuffer;\n};\n\nECPair.prototype.sign = function (hash) {\n  if (!this.d) throw new Error('Missing private key');\n  var sig = fastcurve.sign(hash, this.d);\n  if (sig !== undefined) return sig;\n  return ecdsa.sign(hash, this.d);\n};\n\nECPair.prototype.toWIF = function () {\n  if (!this.d) throw new Error('Missing private key');\n  return wif.encode(this.network.wif, this.d.toBuffer(32), this.compressed);\n};\n\nECPair.prototype.verify = function (hash, signature) {\n  var fastsig = fastcurve.verify(hash, signature, this.getPublicKeyBuffer());\n  if (fastsig !== undefined) return fastsig;\n  return ecdsa.verify(hash, signature, this.Q);\n};\n\nmodule.exports = ECPair;","map":null,"metadata":{},"sourceType":"script"}