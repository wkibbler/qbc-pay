{"ast":null,"code":"'use strict';\n\nlet ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'; // pre-compute lookup table\n\nlet ALPHABET_MAP = {};\n\nfor (let z = 0; z < ALPHABET.length; z++) {\n  let x = ALPHABET.charAt(z);\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous');\n  ALPHABET_MAP[x] = z;\n}\n\nfunction polymodStep(pre) {\n  let b = pre >> 25;\n  return (pre & 0x1FFFFFF) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;\n}\n\nfunction prefixChk(prefix) {\n  let chk = 1;\n\n  for (let i = 0; i < prefix.length; ++i) {\n    let c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error('Invalid prefix (' + prefix + ')');\n    chk = polymodStep(chk) ^ c >> 5;\n  }\n\n  chk = polymodStep(chk);\n\n  for (let i = 0; i < prefix.length; ++i) {\n    let v = prefix.charCodeAt(i);\n    chk = polymodStep(chk) ^ v & 0x1f;\n  }\n\n  return chk;\n}\n\nfunction encode(prefix, words) {\n  // too long?\n  if (prefix.length + 7 + words.length > 90) throw new TypeError('Exceeds Bech32 maximum length');\n  prefix = prefix.toLowerCase(); // determine chk mod\n\n  let chk = prefixChk(prefix);\n  let result = prefix + '1';\n\n  for (let i = 0; i < words.length; ++i) {\n    let x = words[i];\n    if (x >> 5 !== 0) throw new Error('Non 5-bit word');\n    chk = polymodStep(chk) ^ x;\n    result += ALPHABET.charAt(x);\n  }\n\n  for (let i = 0; i < 6; ++i) {\n    chk = polymodStep(chk);\n  }\n\n  chk ^= 1;\n\n  for (let i = 0; i < 6; ++i) {\n    let v = chk >> (5 - i) * 5 & 0x1f;\n    result += ALPHABET.charAt(v);\n  }\n\n  return result;\n}\n\nfunction decode(str) {\n  if (str.length < 8) throw new TypeError(str + ' too short');\n  if (str.length > 90) throw new TypeError(str + ' too long'); // don't allow mixed case\n\n  let lowered = str.toLowerCase();\n  let uppered = str.toUpperCase();\n  if (str !== lowered && str !== uppered) throw new Error('Mixed-case string ' + str);\n  str = lowered;\n  let split = str.lastIndexOf('1');\n  if (split === 0) throw new Error('Missing prefix for ' + str);\n  let prefix = str.slice(0, split);\n  let wordChars = str.slice(split + 1);\n  if (wordChars.length < 6) throw new Error('Data too short');\n  let chk = prefixChk(prefix);\n  let words = [];\n\n  for (let i = 0; i < wordChars.length; ++i) {\n    let c = wordChars.charAt(i);\n    let v = ALPHABET_MAP[c];\n    if (v === undefined) throw new Error('Unknown character ' + c);\n    chk = polymodStep(chk) ^ v; // not in the checksum?\n\n    if (i + 6 >= wordChars.length) continue;\n    words.push(v);\n  }\n\n  if (chk !== 1) throw new Error('Invalid checksum for ' + str);\n  return {\n    prefix,\n    words\n  };\n}\n\nfunction convert(data, inBits, outBits, pad) {\n  let value = 0;\n  let bits = 0;\n  let maxV = (1 << outBits) - 1;\n  let result = [];\n\n  for (let i = 0; i < data.length; ++i) {\n    value = value << inBits | data[i];\n    bits += inBits;\n\n    while (bits >= outBits) {\n      bits -= outBits;\n      result.push(value >> bits & maxV);\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push(value << outBits - bits & maxV);\n    }\n  } else {\n    if (bits >= inBits) throw new Error('Excess padding');\n    if (value << outBits - bits & maxV) throw new Error('Non-zero padding');\n  }\n\n  return result;\n}\n\nfunction toWords(bytes) {\n  return convert(bytes, 8, 5, true);\n}\n\nfunction fromWords(words) {\n  return convert(words, 5, 8, false);\n}\n\nmodule.exports = {\n  decode,\n  encode,\n  toWords,\n  fromWords\n};","map":null,"metadata":{},"sourceType":"script"}