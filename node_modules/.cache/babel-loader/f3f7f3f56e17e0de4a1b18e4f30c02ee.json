{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar BufferWriter = require('./bufferWriter');\n\nvar bcrypto = require('./crypto');\n\nvar bscript = require('./script');\n\nvar bufferutils = require('./bufferutils');\n\nvar coins = require('./coins');\n\nvar opcodes = require('bitcoin-ops');\n\nvar networks = require('./networks');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar varuint = require('varuint-bitcoin');\n\nvar blake2b = require('blake2b');\n\nfunction varSliceSize(someScript) {\n  var length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\n\nfunction vectorSize(someVector) {\n  var length = someVector.length;\n  return varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {\n    return sum + varSliceSize(witness);\n  }, 0);\n} // By default, assume is a bitcoin transaction\n\n\nfunction Transaction(network = networks.bitcoin) {\n  this.version = 1;\n  this.time = Math.floor(new Date().getTime() / 1000);\n  this.locktime = 0;\n  this.ins = [];\n  this.outs = [];\n  this.network = network;\n\n  if (coins.isZcash(network)) {\n    // ZCash version >= 2\n    this.joinsplits = [];\n    this.joinsplitPubkey = [];\n    this.joinsplitSig = []; // ZCash version >= 3\n\n    this.overwintered = 0; // 1 if the transaction is post overwinter upgrade, 0 otherwise\n\n    this.versionGroupId = 0; // 0x03C48270 (63210096) for overwinter and 0x892F2085 (2301567109) for sapling\n\n    this.expiryHeight = 0; // Block height after which this transactions will expire, or 0 to disable expiry\n    // ZCash version >= 4\n\n    this.valueBalance = 0;\n    this.vShieldedSpend = [];\n    this.vShieldedOutput = [];\n    this.bindingSig = 0;\n  }\n}\n\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_BITCOINCASHBIP143 = 0x40;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nvar EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nvar EMPTY_WITNESS = [];\nvar ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\nvar ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'); // Used to represent the absence of a value\n\nvar VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nvar BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX\n};\nTransaction.ZCASH_OVERWINTER_VERSION = 3;\nTransaction.ZCASH_SAPLING_VERSION = 4;\nTransaction.ZCASH_JOINSPLITS_SUPPORT_VERSION = 2;\nTransaction.ZCASH_NUM_JOINSPLITS_INPUTS = 2;\nTransaction.ZCASH_NUM_JOINSPLITS_OUTPUTS = 2;\nTransaction.ZCASH_NOTECIPHERTEXT_SIZE = 1 + 8 + 32 + 32 + 512 + 16;\nTransaction.ZCASH_G1_PREFIX_MASK = 0x02;\nTransaction.ZCASH_G2_PREFIX_MASK = 0x0a;\n\nTransaction.fromBuffer = function (buffer, network = networks.bitcoin, __noStrict) {\n  var offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readUInt8() {\n    var i = buffer.readUInt8(offset);\n    offset += 1;\n    return i;\n  }\n\n  function readUInt32() {\n    var i = buffer.readUInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  function readInt32() {\n    var i = buffer.readInt32LE(offset);\n    offset += 4;\n    return i;\n  }\n\n  function readInt64() {\n    var i = bufferutils.readInt64LE(buffer, offset);\n    offset += 8;\n    return i;\n  }\n\n  function readUInt64() {\n    var i = bufferutils.readUInt64LE(buffer, offset);\n    offset += 8;\n    return i;\n  }\n\n  function readVarInt() {\n    var vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n\n  function readVector() {\n    var count = readVarInt();\n    var vector = [];\n\n    for (var i = 0; i < count; i++) vector.push(readVarSlice());\n\n    return vector;\n  }\n\n  function readCompressedG1() {\n    var yLsb = readUInt8() & 1;\n    var x = readSlice(32);\n    return {\n      x: x,\n      yLsb: yLsb\n    };\n  }\n\n  function readCompressedG2() {\n    var yLsb = readUInt8() & 1;\n    var x = readSlice(64);\n    return {\n      x: x,\n      yLsb: yLsb\n    };\n  }\n\n  function readZKProof() {\n    var zkproof;\n\n    if (tx.isSaplingCompatible()) {\n      zkproof = {\n        sA: readSlice(48),\n        sB: readSlice(96),\n        sC: readSlice(48)\n      };\n    } else {\n      zkproof = {\n        gA: readCompressedG1(),\n        gAPrime: readCompressedG1(),\n        gB: readCompressedG2(),\n        gBPrime: readCompressedG1(),\n        gC: readCompressedG1(),\n        gCPrime: readCompressedG1(),\n        gK: readCompressedG1(),\n        gH: readCompressedG1()\n      };\n    }\n\n    return zkproof;\n  }\n\n  function readJoinSplit() {\n    var vpubOld = readUInt64();\n    var vpubNew = readUInt64();\n    var anchor = readSlice(32);\n    var nullifiers = [];\n\n    for (var j = 0; j < Transaction.ZCASH_NUM_JOINSPLITS_INPUTS; j++) {\n      nullifiers.push(readSlice(32));\n    }\n\n    var commitments = [];\n\n    for (j = 0; j < Transaction.ZCASH_NUM_JOINSPLITS_OUTPUTS; j++) {\n      commitments.push(readSlice(32));\n    }\n\n    var ephemeralKey = readSlice(32);\n    var randomSeed = readSlice(32);\n    var macs = [];\n\n    for (j = 0; j < Transaction.ZCASH_NUM_JOINSPLITS_INPUTS; j++) {\n      macs.push(readSlice(32));\n    }\n\n    var zkproof = readZKProof();\n    var ciphertexts = [];\n\n    for (j = 0; j < Transaction.ZCASH_NUM_JOINSPLITS_OUTPUTS; j++) {\n      ciphertexts.push(readSlice(Transaction.ZCASH_NOTECIPHERTEXT_SIZE));\n    }\n\n    return {\n      vpubOld: vpubOld,\n      vpubNew: vpubNew,\n      anchor: anchor,\n      nullifiers: nullifiers,\n      commitments: commitments,\n      ephemeralKey: ephemeralKey,\n      randomSeed: randomSeed,\n      macs: macs,\n      zkproof: zkproof,\n      ciphertexts: ciphertexts\n    };\n  }\n\n  function readShieldedSpend() {\n    var cv = readSlice(32);\n    var anchor = readSlice(32);\n    var nullifier = readSlice(32);\n    var rk = readSlice(32);\n    var zkproof = readZKProof();\n    var spendAuthSig = readSlice(64);\n    return {\n      cv: cv,\n      anchor: anchor,\n      nullifier: nullifier,\n      rk: rk,\n      zkproof: zkproof,\n      spendAuthSig: spendAuthSig\n    };\n  }\n\n  function readShieldedOutput() {\n    var cv = readSlice(32);\n    var cmu = readSlice(32);\n    var ephemeralKey = readSlice(32);\n    var encCiphertext = readSlice(580);\n    var outCiphertext = readSlice(80);\n    var zkproof = readZKProof();\n    return {\n      cv: cv,\n      cmu: cmu,\n      ephemeralKey: ephemeralKey,\n      encCiphertext: encCiphertext,\n      outCiphertext: outCiphertext,\n      zkproof: zkproof\n    };\n  }\n\n  var tx = new Transaction(network);\n  tx.version = readInt32();\n\n  if (coins.isZcash(network)) {\n    // Split the header into fOverwintered and nVersion\n    tx.overwintered = tx.version >>> 31; // Must be 1 for version 3 and up\n\n    tx.version = tx.version & 0x07FFFFFFF; // 3 for overwinter\n\n    if (!network.consensusBranchId.hasOwnProperty(tx.version)) {\n      throw new Error('Unsupported Zcash transaction');\n    }\n  }\n\n  var marker = buffer.readUInt8(offset);\n  var flag = buffer.readUInt8(offset + 1);\n  var hasWitnesses = false;\n\n  if (marker === Transaction.ADVANCED_TRANSACTION_MARKER && flag === Transaction.ADVANCED_TRANSACTION_FLAG && !coins.isZcash(network)) {\n    offset += 2;\n    hasWitnesses = true;\n  }\n\n  if (tx.isOverwinterCompatible()) {\n    tx.versionGroupId = readUInt32();\n  }\n\n  var vinLen = readVarInt();\n\n  for (var i = 0; i < vinLen; ++i) {\n    tx.ins.push({\n      hash: readSlice(32),\n      index: readUInt32(),\n      script: readVarSlice(),\n      sequence: readUInt32(),\n      witness: EMPTY_WITNESS\n    });\n  }\n\n  var voutLen = readVarInt();\n\n  for (i = 0; i < voutLen; ++i) {\n    tx.outs.push({\n      value: readUInt64(),\n      script: readVarSlice()\n    });\n  }\n\n  if (hasWitnesses) {\n    for (i = 0; i < vinLen; ++i) {\n      tx.ins[i].witness = readVector();\n    } // was this pointless?\n\n\n    if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data');\n  }\n\n  tx.locktime = readUInt32();\n\n  if (coins.isZcash(network)) {\n    if (tx.isOverwinterCompatible()) {\n      tx.expiryHeight = readUInt32();\n    }\n\n    if (tx.isSaplingCompatible()) {\n      tx.valueBalance = readInt64();\n      var nShieldedSpend = readVarInt();\n\n      for (i = 0; i < nShieldedSpend; ++i) {\n        tx.vShieldedSpend.push(readShieldedSpend());\n      }\n\n      var nShieldedOutput = readVarInt();\n\n      for (i = 0; i < nShieldedOutput; ++i) {\n        tx.vShieldedOutput.push(readShieldedOutput());\n      }\n    }\n\n    if (tx.supportsJoinSplits()) {\n      var joinSplitsLen = readVarInt();\n\n      for (i = 0; i < joinSplitsLen; ++i) {\n        tx.joinsplits.push(readJoinSplit());\n      }\n\n      if (joinSplitsLen > 0) {\n        tx.joinsplitPubkey = readSlice(32);\n        tx.joinsplitSig = readSlice(64);\n      }\n    }\n\n    if (tx.isSaplingCompatible() && tx.vShieldedSpend.length + tx.vShieldedOutput.length > 0) {\n      tx.bindingSig = readSlice(64);\n    }\n  }\n\n  tx.network = network;\n  if (__noStrict) return tx;\n  if (offset !== buffer.length) throw new Error('Transaction has unexpected data');\n  return tx;\n};\n\nTransaction.fromHex = function (hex, network) {\n  return Transaction.fromBuffer(Buffer.from(hex, 'hex'), network);\n};\n\nTransaction.isCoinbaseHash = function (buffer) {\n  typeforce(types.Hash256bit, buffer);\n\n  for (var i = 0; i < 32; ++i) {\n    if (buffer[i] !== 0) return false;\n  }\n\n  return true;\n};\n\nTransaction.prototype.isSaplingCompatible = function () {\n  return coins.isZcash(this.network) && this.version >= Transaction.ZCASH_SAPLING_VERSION;\n};\n\nTransaction.prototype.isOverwinterCompatible = function () {\n  return coins.isZcash(this.network) && this.version >= Transaction.ZCASH_OVERWINTER_VERSION;\n};\n\nTransaction.prototype.supportsJoinSplits = function () {\n  return coins.isZcash(this.network) && this.version >= Transaction.ZCASH_JOINSPLITS_SUPPORT_VERSION;\n};\n\nTransaction.prototype.isCoinbase = function () {\n  return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);\n};\n\nTransaction.prototype.addInput = function (hash, index, sequence, scriptSig) {\n  typeforce(types.tuple(types.Hash256bit, types.UInt32, types.maybe(types.UInt32), types.maybe(types.Buffer)), arguments);\n\n  if (types.Null(sequence)) {\n    sequence = Transaction.DEFAULT_SEQUENCE;\n  } // Add the input and return the input's index\n\n\n  return this.ins.push({\n    hash: hash,\n    index: index,\n    script: scriptSig || EMPTY_SCRIPT,\n    sequence: sequence,\n    witness: EMPTY_WITNESS\n  }) - 1;\n};\n\nTransaction.prototype.addOutput = function (scriptPubKey, value) {\n  typeforce(types.tuple(types.Buffer, types.Satoshi), arguments); // Add the output and return the output's index\n\n  return this.outs.push({\n    script: scriptPubKey,\n    value: value\n  }) - 1;\n};\n\nTransaction.prototype.hasWitnesses = function () {\n  return this.ins.some(function (x) {\n    return x.witness.length !== 0;\n  });\n};\n\nTransaction.prototype.weight = function () {\n  var base = this.__byteLength(false);\n\n  var total = this.__byteLength(true);\n\n  return base * 3 + total;\n};\n\nTransaction.prototype.virtualSize = function () {\n  return Math.ceil(this.weight() / 4);\n};\n\nTransaction.prototype.byteLength = function () {\n  return this.__byteLength(true);\n};\n\nTransaction.prototype.getShieldedSpendByteLength = function () {\n  if (!this.isSaplingCompatible()) {\n    return 0;\n  }\n\n  var byteLength = 0;\n  byteLength += varuint.encodingLength(this.vShieldedSpend.length); // nShieldedSpend\n\n  byteLength += 384 * this.vShieldedSpend.length; // vShieldedSpend\n\n  return byteLength;\n};\n\nTransaction.prototype.getShieldedOutputByteLength = function () {\n  if (!this.isSaplingCompatible()) {\n    return 0;\n  }\n\n  var byteLength = 0;\n  byteLength += varuint.encodingLength(this.vShieldedOutput.length); // nShieldedOutput\n\n  byteLength += 948 * this.vShieldedOutput.length; // vShieldedOutput\n\n  return byteLength;\n};\n\nTransaction.prototype.getJoinSplitByteLength = function () {\n  if (!this.supportsJoinSplits()) {\n    return 0;\n  }\n\n  var joinSplitsLen = this.joinsplits.length;\n  var byteLength = 0;\n  byteLength += bufferutils.varIntSize(joinSplitsLen); // vJoinSplit\n\n  if (joinSplitsLen > 0) {\n    // Both pre and post Sapling JoinSplits are encoded with the following data:\n    // 8 vpub_old, 8 vpub_new, 32 anchor, joinSplitsLen * 32 nullifiers, joinSplitsLen * 32 commitments, 32 ephemeralKey\n    // 32 ephemeralKey, 32 randomSeed, joinsplit.macs.length * 32 vmacs\n    if (this.isSaplingCompatible()) {\n      byteLength += 1698 * joinSplitsLen; // vJoinSplit using JSDescriptionGroth16\n    } else {\n      byteLength += 1802 * joinSplitsLen; // vJoinSplit using JSDescriptionPHGR13\n    }\n\n    byteLength += 32; // joinSplitPubKey\n\n    byteLength += 64; // joinSplitSig\n  }\n\n  return byteLength;\n};\n\nTransaction.prototype.zcashTransactionByteLength = function () {\n  if (!coins.isZcash(this.network)) {\n    throw new Error('zcashTransactionByteLength can only be called when using Zcash network');\n  }\n\n  var byteLength = 0;\n  byteLength += 4; // Header\n\n  if (this.isOverwinterCompatible()) {\n    byteLength += 4; // nVersionGroupId\n  }\n\n  byteLength += varuint.encodingLength(this.ins.length); // tx_in_count\n\n  byteLength += this.ins.reduce(function (sum, input) {\n    return sum + 40 + varSliceSize(input.script);\n  }, 0); // tx_in\n\n  byteLength += varuint.encodingLength(this.outs.length); // tx_out_count\n\n  byteLength += this.outs.reduce(function (sum, output) {\n    return sum + 8 + varSliceSize(output.script);\n  }, 0); // tx_out\n\n  byteLength += 4; // lock_time\n\n  if (this.isOverwinterCompatible()) {\n    byteLength += 4; // nExpiryHeight\n  }\n\n  if (this.isSaplingCompatible()) {\n    byteLength += 8; // valueBalance\n\n    byteLength += this.getShieldedSpendByteLength();\n    byteLength += this.getShieldedOutputByteLength();\n  }\n\n  if (this.supportsJoinSplits()) {\n    byteLength += this.getJoinSplitByteLength();\n  }\n\n  if (this.isSaplingCompatible() && this.vShieldedSpend.length + this.vShieldedOutput.length > 0) {\n    byteLength += 64; // bindingSig\n  }\n\n  return byteLength;\n};\n\nTransaction.prototype.__byteLength = function (__allowWitness) {\n  var hasWitnesses = __allowWitness && this.hasWitnesses();\n\n  if (coins.isZcash(this.network)) {\n    return this.zcashTransactionByteLength();\n  }\n\n  return (hasWitnesses ? 10 : 8) + varuint.encodingLength(this.ins.length) + varuint.encodingLength(this.outs.length) + this.ins.reduce(function (sum, input) {\n    return sum + 40 + varSliceSize(input.script);\n  }, 0) + this.outs.reduce(function (sum, output) {\n    return sum + 8 + varSliceSize(output.script);\n  }, 0) + (hasWitnesses ? this.ins.reduce(function (sum, input) {\n    return sum + vectorSize(input.witness);\n  }, 0) : 0);\n};\n\nTransaction.prototype.clone = function () {\n  var newTx = new Transaction(this.network);\n  newTx.version = this.version;\n  newTx.locktime = this.locktime;\n  newTx.network = this.network;\n\n  if (this.isOverwinterCompatible()) {\n    newTx.overwintered = this.overwintered;\n    newTx.versionGroupId = this.versionGroupId;\n    newTx.expiryHeight = this.expiryHeight;\n  }\n\n  if (this.isSaplingCompatible()) {\n    newTx.valueBalance = this.valueBalance;\n  }\n\n  newTx.ins = this.ins.map(function (txIn) {\n    return {\n      hash: txIn.hash,\n      index: txIn.index,\n      script: txIn.script,\n      sequence: txIn.sequence,\n      witness: txIn.witness\n    };\n  });\n  newTx.outs = this.outs.map(function (txOut) {\n    return {\n      script: txOut.script,\n      value: txOut.value\n    };\n  });\n\n  if (this.isSaplingCompatible()) {\n    newTx.vShieldedSpend = this.vShieldedSpend.map(function (shieldedSpend) {\n      return {\n        cv: shieldedSpend.cv,\n        anchor: shieldedSpend.anchor,\n        nullifier: shieldedSpend.nullifier,\n        rk: shieldedSpend.rk,\n        zkproof: shieldedSpend.zkproof,\n        spendAuthSig: shieldedSpend.spendAuthSig\n      };\n    });\n    newTx.vShieldedOutput = this.vShieldedOutput.map(function (shieldedOutput) {\n      return {\n        cv: shieldedOutput.cv,\n        cmu: shieldedOutput.cmu,\n        ephemeralKey: shieldedOutput.ephemeralKey,\n        encCiphertext: shieldedOutput.encCiphertext,\n        outCiphertext: shieldedOutput.outCiphertext,\n        zkproof: shieldedOutput.zkproof\n      };\n    });\n  }\n\n  if (this.supportsJoinSplits()) {\n    newTx.joinsplits = this.joinsplits.map(function (txJoinsplit) {\n      return {\n        vpubOld: txJoinsplit.vpubOld,\n        vpubNew: txJoinsplit.vpubNew,\n        anchor: txJoinsplit.anchor,\n        nullifiers: txJoinsplit.nullifiers,\n        commitments: txJoinsplit.commitments,\n        ephemeralKey: txJoinsplit.ephemeralKey,\n        randomSeed: txJoinsplit.randomSeed,\n        macs: txJoinsplit.macs,\n        zkproof: txJoinsplit.zkproof,\n        ciphertexts: txJoinsplit.ciphertexts\n      };\n    });\n    newTx.joinsplitPubkey = this.joinsplitPubkey;\n    newTx.joinsplitSig = this.joinsplitSig;\n  }\n\n  if (this.isSaplingCompatible() && this.vShieldedSpend.length + this.vShieldedOutput.length > 0) {\n    newTx.bindingSig = this.bindingSig;\n  }\n\n  return newTx;\n};\n/**\n * Get Zcash header or version\n * @returns {number}\n */\n\n\nTransaction.prototype.getHeader = function () {\n  var mask = this.overwintered ? 1 : 0;\n  var header = this.version | mask << 31;\n  return header;\n};\n/**\n * Hash transaction for signing a specific input.\n *\n * Bitcoin uses a different hash for each signed transaction input.\n * This method copies the transaction, makes the necessary changes based on the\n * hashType, and then hashes the result.\n * This hash can then be used to sign the provided transaction input.\n */\n\n\nTransaction.prototype.hashForSignature = function (inIndex, prevOutScript, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer,\n  /* types.UInt8 */\n  types.Number), arguments); // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n\n  if (inIndex >= this.ins.length) return ONE; // ignore OP_CODESEPARATOR\n\n  var ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(function (x) {\n    return x !== opcodes.OP_CODESEPARATOR;\n  }));\n  var txTmp = this.clone(); // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n\n  if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n    txTmp.outs = []; // ignore sequence numbers (except at inIndex)\n\n    txTmp.ins.forEach(function (input, i) {\n      if (i === inIndex) return;\n      input.sequence = 0;\n    }); // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n    if (inIndex >= this.outs.length) return ONE; // truncate outputs after\n\n    txTmp.outs.length = inIndex + 1; // \"blank\" outputs before\n\n    for (var i = 0; i < inIndex; i++) {\n      txTmp.outs[i] = BLANK_OUTPUT;\n    } // ignore sequence numbers (except at inIndex)\n\n\n    txTmp.ins.forEach(function (input, y) {\n      if (y === inIndex) return;\n      input.sequence = 0;\n    });\n  } // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n\n\n  if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n    txTmp.ins = [txTmp.ins[inIndex]];\n    txTmp.ins[0].script = ourScript; // SIGHASH_ALL: only ignore input scripts\n  } else {\n    // \"blank\" others input scripts\n    txTmp.ins.forEach(function (input) {\n      input.script = EMPTY_SCRIPT;\n    });\n    txTmp.ins[inIndex].script = ourScript;\n  } // serialize and hash\n\n\n  var buffer = Buffer.allocUnsafe(txTmp.__byteLength(false) + 4);\n  buffer.writeInt32LE(hashType, buffer.length - 4);\n\n  txTmp.__toBuffer(buffer, 0, false);\n\n  return bcrypto.hash256(buffer);\n};\n/**\n * Blake2b hashing algorithm for Zcash\n * @param bufferToHash\n * @param personalization\n * @returns 256-bit BLAKE2b hash\n */\n\n\nTransaction.prototype.getBlake2bHash = function (bufferToHash, personalization) {\n  var out = Buffer.allocUnsafe(32);\n  return blake2b(out.length, null, null, Buffer.from(personalization)).update(bufferToHash).digest(out);\n};\n/**\n * Build a hash for all or none of the transaction inputs depending on the hashtype\n * @param hashType\n * @returns double SHA-256, 256-bit BLAKE2b hash or 256-bit zero if doesn't apply\n */\n\n\nTransaction.prototype.getPrevoutHash = function (hashType) {\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n    var bufferWriter = new BufferWriter(36 * this.ins.length);\n    this.ins.forEach(function (txIn) {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n    });\n\n    if (coins.isZcash(this.network)) {\n      return this.getBlake2bHash(bufferWriter.getBuffer(), 'ZcashPrevoutHash');\n    }\n\n    return bcrypto.hash256(bufferWriter.getBuffer());\n  }\n\n  return ZERO;\n};\n/**\n * Build a hash for all or none of the transactions inputs sequence numbers depending on the hashtype\n * @param hashType\n * @returns double SHA-256, 256-bit BLAKE2b hash or 256-bit zero if doesn't apply\n */\n\n\nTransaction.prototype.getSequenceHash = function (hashType) {\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) && (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    var bufferWriter = new BufferWriter(4 * this.ins.length);\n    this.ins.forEach(function (txIn) {\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n\n    if (coins.isZcash(this.network)) {\n      return this.getBlake2bHash(bufferWriter.getBuffer(), 'ZcashSequencHash');\n    }\n\n    return bcrypto.hash256(bufferWriter.getBuffer());\n  }\n\n  return ZERO;\n};\n/**\n * Build a hash for one, all or none of the transaction outputs depending on the hashtype\n * @param hashType\n * @param inIndex\n * @returns double SHA-256, 256-bit BLAKE2b hash or 256-bit zero if doesn't apply\n */\n\n\nTransaction.prototype.getOutputsHash = function (hashType, inIndex) {\n  var bufferWriter;\n\n  if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    // Find out the size of the outputs and write them\n    var txOutsSize = this.outs.reduce(function (sum, output) {\n      return sum + 8 + varSliceSize(output.script);\n    }, 0);\n    bufferWriter = new BufferWriter(txOutsSize);\n    this.outs.forEach(function (out) {\n      bufferWriter.writeUInt64(out.value);\n      bufferWriter.writeVarSlice(out.script);\n    });\n\n    if (coins.isZcash(this.network)) {\n      return this.getBlake2bHash(bufferWriter.getBuffer(), 'ZcashOutputsHash');\n    }\n\n    return bcrypto.hash256(bufferWriter.getBuffer());\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {\n    // Write only the output specified in inIndex\n    var output = this.outs[inIndex];\n    bufferWriter = new BufferWriter(8 + varSliceSize(output.script));\n    bufferWriter.writeUInt64(output.value);\n    bufferWriter.writeVarSlice(output.script);\n\n    if (coins.isZcash(this.network)) {\n      return this.getBlake2bHash(bufferWriter.getBuffer(), 'ZcashOutputsHash');\n    }\n\n    return bcrypto.hash256(bufferWriter.getBuffer());\n  }\n\n  return ZERO;\n};\n/**\n * Hash transaction for signing a transparent transaction in Zcash. Protected transactions are not supported.\n * @param inIndex\n * @param prevOutScript\n * @param value\n * @param hashType\n * @returns double SHA-256 or 256-bit BLAKE2b hash\n */\n\n\nTransaction.prototype.hashForZcashSignature = function (inIndex, prevOutScript, value, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n\n  if (!coins.isZcash(this.network)) {\n    throw new Error('hashForZcashSignature can only be called when using Zcash network');\n  }\n\n  if (this.joinsplits.length > 0) {\n    throw new Error('Hash signature for Zcash protected transactions is not supported');\n  }\n\n  if (inIndex >= this.ins.length && inIndex !== VALUE_UINT64_MAX) {\n    throw new Error('Input index is out of range');\n  }\n\n  if (this.isOverwinterCompatible()) {\n    var hashPrevouts = this.getPrevoutHash(hashType);\n    var hashSequence = this.getSequenceHash(hashType);\n    var hashOutputs = this.getOutputsHash(hashType, inIndex);\n    var hashJoinSplits = ZERO;\n    var hashShieldedSpends = ZERO;\n    var hashShieldedOutputs = ZERO;\n    var bufferWriter;\n    var baseBufferSize = 0;\n    baseBufferSize += 4 * 5; // header, nVersionGroupId, lock_time, nExpiryHeight, hashType\n\n    baseBufferSize += 32 * 4; // 256 hashes: hashPrevouts, hashSequence, hashOutputs, hashJoinSplits\n\n    if (inIndex !== VALUE_UINT64_MAX) {\n      // If this hash is for a transparent input signature (i.e. not for txTo.joinSplitSig), we need extra space\n      baseBufferSize += 4 * 2; // input.index, input.sequence\n\n      baseBufferSize += 8; // value\n\n      baseBufferSize += 32; // input.hash\n\n      baseBufferSize += varSliceSize(prevOutScript); // prevOutScript\n    }\n\n    if (this.isSaplingCompatible()) {\n      baseBufferSize += 32 * 2; // hashShieldedSpends and hashShieldedOutputs\n\n      baseBufferSize += 8; // valueBalance\n    }\n\n    bufferWriter = new BufferWriter(baseBufferSize);\n    bufferWriter.writeInt32(this.getHeader());\n    bufferWriter.writeUInt32(this.versionGroupId);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeSlice(hashJoinSplits);\n\n    if (this.isSaplingCompatible()) {\n      bufferWriter.writeSlice(hashShieldedSpends);\n      bufferWriter.writeSlice(hashShieldedOutputs);\n    }\n\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(this.expiryHeight);\n\n    if (this.isSaplingCompatible()) {\n      bufferWriter.writeUInt64(this.valueBalance);\n    }\n\n    bufferWriter.writeUInt32(hashType); // If this hash is for a transparent input signature (i.e. not for txTo.joinSplitSig):\n\n    if (inIndex !== VALUE_UINT64_MAX) {\n      // The input being signed (replacing the scriptSig with scriptCode + amount)\n      // The prevout may already be contained in hashPrevout, and the nSequence\n      // may already be contained in hashSequence.\n      var input = this.ins[inIndex];\n      bufferWriter.writeSlice(input.hash);\n      bufferWriter.writeUInt32(input.index);\n      bufferWriter.writeVarSlice(prevOutScript);\n      bufferWriter.writeUInt64(value);\n      bufferWriter.writeUInt32(input.sequence);\n    }\n\n    var personalization = Buffer.alloc(16);\n    var prefix = 'ZcashSigHash';\n    personalization.write(prefix);\n    personalization.writeUInt32LE(this.network.consensusBranchId[this.version], prefix.length);\n    return this.getBlake2bHash(bufferWriter.getBuffer(), personalization);\n  } // TODO: support non overwinter transactions\n\n};\n\nTransaction.prototype.hashForWitnessV0 = function (inIndex, prevOutScript, value, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n  var hashPrevouts = this.getPrevoutHash(hashType);\n  var hashSequence = this.getSequenceHash(hashType);\n  var hashOutputs = this.getOutputsHash(hashType, inIndex);\n  var bufferWriter = new BufferWriter(156 + varSliceSize(prevOutScript));\n  var input = this.ins[inIndex];\n  bufferWriter.writeUInt32(this.version);\n  bufferWriter.writeSlice(hashPrevouts);\n  bufferWriter.writeSlice(hashSequence);\n  bufferWriter.writeSlice(input.hash);\n  bufferWriter.writeUInt32(input.index);\n  bufferWriter.writeVarSlice(prevOutScript);\n  bufferWriter.writeUInt64(value);\n  bufferWriter.writeUInt32(input.sequence);\n  bufferWriter.writeSlice(hashOutputs);\n  bufferWriter.writeUInt32(this.locktime);\n  bufferWriter.writeUInt32(hashType);\n  return bcrypto.hash256(bufferWriter.getBuffer());\n};\n/**\n * Hash transaction for signing a specific input for Bitcoin Cash.\n */\n\n\nTransaction.prototype.hashForCashSignature = function (inIndex, prevOutScript, inAmount, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer,\n  /* types.UInt8 */\n  types.Number, types.maybe(types.UInt53)), arguments); // This function works the way it does because Bitcoin Cash\n  // uses BIP143 as their replay protection, AND their algo\n  // includes `forkId | hashType`, AND since their forkId=0,\n  // this is a NOP, and has no difference to segwit. To support\n  // other forks, another parameter is required, and a new parameter\n  // would be required in the hashForWitnessV0 function, or\n  // it could be broken into two..\n  // BIP143 sighash activated in BitcoinCash via 0x40 bit\n\n  if (hashType & Transaction.SIGHASH_BITCOINCASHBIP143) {\n    if (types.Null(inAmount)) {\n      throw new Error('Bitcoin Cash sighash requires value of input to be signed.');\n    }\n\n    return this.hashForWitnessV0(inIndex, prevOutScript, inAmount, hashType);\n  } else {\n    return this.hashForSignature(inIndex, prevOutScript, hashType);\n  }\n};\n/**\n * Hash transaction for signing a specific input for Bitcoin Gold.\n */\n\n\nTransaction.prototype.hashForGoldSignature = function (inIndex, prevOutScript, inAmount, hashType, sigVersion) {\n  typeforce(types.tuple(types.UInt32, types.Buffer,\n  /* types.UInt8 */\n  types.Number, types.maybe(types.UInt53)), arguments); // Bitcoin Gold also implements segregated witness\n  // therefore we can pull out the setting of nForkHashType\n  // and pass it into the functions.\n\n  var nForkHashType = hashType;\n  var fUseForkId = (hashType & Transaction.SIGHASH_BITCOINCASHBIP143) > 0;\n\n  if (fUseForkId) {\n    nForkHashType |= this.network.forkId << 8;\n  } // BIP143 sighash activated in BitcoinCash via 0x40 bit\n\n\n  if (sigVersion || fUseForkId) {\n    if (types.Null(inAmount)) {\n      throw new Error('Bitcoin Cash sighash requires value of input to be signed.');\n    }\n\n    return this.hashForWitnessV0(inIndex, prevOutScript, inAmount, nForkHashType);\n  } else {\n    return this.hashForSignature(inIndex, prevOutScript, nForkHashType);\n  }\n};\n\nTransaction.prototype.getHash = function () {\n  return bcrypto.hash256(this.__toBuffer(undefined, undefined, false));\n};\n\nTransaction.prototype.getId = function () {\n  // transaction hash's are displayed in reverse order\n  return this.getHash().reverse().toString('hex');\n};\n\nTransaction.prototype.toBuffer = function (buffer, initialOffset) {\n  return this.__toBuffer(buffer, initialOffset, true);\n};\n\nTransaction.prototype.__toBuffer = function (buffer, initialOffset, __allowWitness) {\n  if (!buffer) buffer = Buffer.allocUnsafe(this.__byteLength(__allowWitness));\n  var offset = initialOffset || 0;\n\n  function writeSlice(slice) {\n    offset += slice.copy(buffer, offset);\n  }\n\n  function writeUInt8(i) {\n    offset = buffer.writeUInt8(i, offset);\n  }\n\n  function writeUInt32(i) {\n    offset = buffer.writeUInt32LE(i, offset);\n  }\n\n  function writeInt32(i) {\n    offset = buffer.writeInt32LE(i, offset);\n  }\n\n  function writeUInt64(i) {\n    offset = bufferutils.writeUInt64LE(buffer, i, offset);\n  }\n\n  function writeVarInt(i) {\n    varuint.encode(i, buffer, offset);\n    offset += varuint.encode.bytes;\n  }\n\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n\n  function writeCompressedG1(i) {\n    writeUInt8(Transaction.ZCASH_G1_PREFIX_MASK | i.yLsb);\n    writeSlice(i.x);\n  }\n\n  function writeCompressedG2(i) {\n    writeUInt8(Transaction.ZCASH_G2_PREFIX_MASK | i.yLsb);\n    writeSlice(i.x);\n  }\n\n  if (this.isOverwinterCompatible()) {\n    var mask = this.overwintered ? 1 : 0;\n    writeInt32(this.version | mask << 31); // Set overwinter bit\n\n    writeUInt32(this.versionGroupId);\n  } else {\n    writeInt32(this.version);\n  }\n\n  var hasWitnesses = __allowWitness && this.hasWitnesses();\n\n  if (hasWitnesses) {\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n    writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n  }\n\n  writeVarInt(this.ins.length);\n  this.ins.forEach(function (txIn) {\n    writeSlice(txIn.hash);\n    writeUInt32(txIn.index);\n    writeVarSlice(txIn.script);\n    writeUInt32(txIn.sequence);\n  });\n  writeVarInt(this.outs.length);\n  this.outs.forEach(function (txOut) {\n    if (!txOut.valueBuffer) {\n      writeUInt64(txOut.value);\n    } else {\n      writeSlice(txOut.valueBuffer);\n    }\n\n    writeVarSlice(txOut.script);\n  });\n\n  if (hasWitnesses) {\n    this.ins.forEach(function (input) {\n      writeVector(input.witness);\n    });\n  }\n\n  writeUInt32(this.locktime);\n\n  if (this.isOverwinterCompatible()) {\n    writeUInt32(this.expiryHeight);\n  }\n\n  if (this.isSaplingCompatible()) {\n    writeUInt64(this.valueBalance);\n    writeVarInt(this.vShieldedSpend.length);\n    this.vShieldedSpend.forEach(function (shieldedSpend) {\n      writeSlice(shieldedSpend.cv);\n      writeSlice(shieldedSpend.anchor);\n      writeSlice(shieldedSpend.nullifier);\n      writeSlice(shieldedSpend.rk);\n      writeSlice(shieldedSpend.zkproof.sA);\n      writeSlice(shieldedSpend.zkproof.sB);\n      writeSlice(shieldedSpend.zkproof.sC);\n      writeSlice(shieldedSpend.spendAuthSig);\n    });\n    writeVarInt(this.vShieldedOutput.length);\n    this.vShieldedOutput.forEach(function (shieldedOutput) {\n      writeSlice(shieldedOutput.cv);\n      writeSlice(shieldedOutput.cmu);\n      writeSlice(shieldedOutput.ephemeralKey);\n      writeSlice(shieldedOutput.encCiphertext);\n      writeSlice(shieldedOutput.outCiphertext);\n      writeSlice(shieldedOutput.zkproof.sA);\n      writeSlice(shieldedOutput.zkproof.sB);\n      writeSlice(shieldedOutput.zkproof.sC);\n    });\n  }\n\n  if (this.supportsJoinSplits()) {\n    writeVarInt(this.joinsplits.length);\n    this.joinsplits.forEach(function (joinsplit) {\n      writeUInt64(joinsplit.vpubOld);\n      writeUInt64(joinsplit.vpubNew);\n      writeSlice(joinsplit.anchor);\n      joinsplit.nullifiers.forEach(function (nullifier) {\n        writeSlice(nullifier);\n      });\n      joinsplit.commitments.forEach(function (nullifier) {\n        writeSlice(nullifier);\n      });\n      writeSlice(joinsplit.ephemeralKey);\n      writeSlice(joinsplit.randomSeed);\n      joinsplit.macs.forEach(function (nullifier) {\n        writeSlice(nullifier);\n      });\n\n      if (this.isSaplingCompatible()) {\n        writeSlice(joinsplit.zkproof.sA);\n        writeSlice(joinsplit.zkproof.sB);\n        writeSlice(joinsplit.zkproof.sC);\n      } else {\n        writeCompressedG1(joinsplit.zkproof.gA);\n        writeCompressedG1(joinsplit.zkproof.gAPrime);\n        writeCompressedG2(joinsplit.zkproof.gB);\n        writeCompressedG1(joinsplit.zkproof.gBPrime);\n        writeCompressedG1(joinsplit.zkproof.gC);\n        writeCompressedG1(joinsplit.zkproof.gCPrime);\n        writeCompressedG1(joinsplit.zkproof.gK);\n        writeCompressedG1(joinsplit.zkproof.gH);\n      }\n\n      joinsplit.ciphertexts.forEach(function (ciphertext) {\n        writeSlice(ciphertext);\n      });\n    }, this);\n\n    if (this.joinsplits.length > 0) {\n      writeSlice(this.joinsplitPubkey);\n      writeSlice(this.joinsplitSig);\n    }\n  }\n\n  if (this.isSaplingCompatible() && this.vShieldedSpend.length + this.vShieldedOutput.length > 0) {\n    writeSlice(this.bindingSig);\n  } // avoid slicing unless necessary\n\n\n  if (initialOffset !== undefined) return buffer.slice(initialOffset, offset); // TODO (https://github.com/BitGo/bitgo-utxo-lib/issues/11): we shouldn't have to slice the final buffer\n\n  return buffer.slice(0, offset);\n};\n\nTransaction.prototype.toHex = function () {\n  return this.toBuffer().toString('hex');\n};\n\nTransaction.prototype.setInputScript = function (index, scriptSig) {\n  typeforce(types.tuple(types.Number, types.Buffer), arguments);\n  this.ins[index].script = scriptSig;\n};\n\nTransaction.prototype.setWitness = function (index, witness) {\n  typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n  this.ins[index].witness = witness;\n};\n\nmodule.exports = Transaction;","map":null,"metadata":{},"sourceType":"script"}